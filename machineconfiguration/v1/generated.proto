
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.openshift.api.machineconfiguration.v1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1";

message AWSPlatformSpec {
  // serviceEndpoints list contains custom endpoints which will override default
  // service endpoint of AWS Services.
  // There must be only one ServiceEndpoint for a service.
  // +optional
  repeated AWSServiceEndpoint serviceEndpoints = 1;
}

message AWSPlatformStatus {
  // region holds the default AWS region for new AWS resources created by the cluster.
  optional string region = 1;

  // ServiceEndpoints list contains custom endpoints which will override default
  // service endpoint of AWS Services.
  // There must be only one ServiceEndpoint for a service.
  // +optional
  repeated AWSServiceEndpoint serviceEndpoints = 2;

  // resourceTags is a list of additional tags to apply to AWS resources created for the cluster.
  // See https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html for information on tagging AWS resources.
  // AWS supports a maximum of 50 tags per resource. OpenShift reserves 25 tags for its use, leaving 25 tags
  // available for the user.
  // +kubebuilder:validation:MaxItems=25
  // +optional
  repeated AWSResourceTag resourceTags = 3;
}

message AWSResourceTag {
  // key is the key of the tag
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:MinLength=1
  // +kubebuilder:validation:MaxLength=128
  // +kubebuilder:validation:Pattern=`^[0-9A-Za-z_.:/=+-@]+$`
  // +required
  optional string key = 1;

  // value is the value of the tag.
  // Some AWS service do not support empty values. Since tags are added to resources in many services, the
  // length of the tag value must meet the requirements of all services.
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:MinLength=1
  // +kubebuilder:validation:MaxLength=256
  // +kubebuilder:validation:Pattern=`^[0-9A-Za-z_.:/=+-@]+$`
  // +required
  optional string value = 2;
}

message AWSServiceEndpoint {
  // name is the name of the AWS service.
  // The list of all the service names can be found at https://docs.aws.amazon.com/general/latest/gr/aws-service-information.html
  // This must be provided and cannot be empty.
  //
  // +kubebuilder:validation:Pattern=`^[a-z0-9-]+$`
  optional string name = 1;

  // url is fully qualified URI with scheme https, that overrides the default generated
  // endpoint for a client.
  // This must be provided and cannot be empty.
  //
  // +kubebuilder:validation:Pattern=`^https://`
  optional string url = 2;
}

message AlibabaCloudPlatformSpec {
}

message AlibabaCloudPlatformStatus {
  // region specifies the region for Alibaba Cloud resources created for the cluster.
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:Pattern=`^[0-9A-Za-z-]+$`
  // +required
  optional string region = 1;

  // resourceGroupID is the ID of the resource group for the cluster.
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:Pattern=`^rg-[0-9A-Za-z]+$`
  // +required
  optional string resourceGroupID = 2;

  // resourceTags is a list of additional tags to apply to Alibaba Cloud resources created for the cluster.
  // +kubebuilder:validation:MaxItems=20
  // +listType=map
  // +listMapKey=key
  // +optional
  repeated AlibabaCloudResourceTag resourceTags = 3;
}

message AlibabaCloudResourceTag {
  // key is the key of the tag.
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:MinLength=1
  // +kubebuilder:validation:MaxLength=128
  // +required
  optional string key = 1;

  // value is the value of the tag.
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:MinLength=1
  // +kubebuilder:validation:MaxLength=128
  // +required
  optional string value = 2;
}

message AzurePlatformSpec {
}

message AzurePlatformStatus {
  // resourceGroupName is the Resource Group for new Azure resources created for the cluster.
  optional string resourceGroupName = 1;

  // networkResourceGroupName is the Resource Group for network resources like the Virtual Network and Subnets used by the cluster.
  // If empty, the value is same as ResourceGroupName.
  // +optional
  optional string networkResourceGroupName = 2;

  // cloudName is the name of the Azure cloud environment which can be used to configure the Azure SDK
  // with the appropriate Azure API endpoints.
  // If empty, the value is equal to `AzurePublicCloud`.
  // +optional
  optional string cloudName = 3;

  // armEndpoint specifies a URL to use for resource management in non-soverign clouds such as Azure Stack.
  // +optional
  optional string armEndpoint = 4;
}

message BareMetalPlatformSpec {
}

message BareMetalPlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 2;

  // nodeDNSIP is the IP address for the internal DNS used by the
  // nodes. Unlike the one managed by the DNS operator, `NodeDNSIP`
  // provides name resolution for the nodes themselves. There is no DNS-as-a-service for
  // BareMetal deployments. In order to minimize necessary changes to the
  // datacenter DNS, a DNS service is hosted as a static pod to serve those hostnames
  // to the nodes in the cluster.
  optional string nodeDNSIP = 3;
}

message ConfigMapFileReference {
  optional string name = 1;

  // Key allows pointing to a specific key/value inside of the configmap.  This is useful for logical file references.
  optional string key = 2;
}

message CustomTLSProfile {
  optional TLSProfileSpec tLSProfileSpec = 1;
}

message DNS {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // spec holds user settable values for configuration
  // +kubebuilder:validation:Required
  // +required
  optional DNSSpec spec = 2;

  // status holds observed values from the cluster. They may not be overridden.
  // +optional
  optional DNSStatus status = 3;
}

message DNSSpec {
  // baseDomain is the base domain of the cluster. All managed DNS records will
  // be sub-domains of this base.
  //
  // For example, given the base domain `openshift.example.com`, an API server
  // DNS record may be created for `cluster-api.openshift.example.com`.
  //
  // Once set, this field cannot be changed.
  optional string baseDomain = 1;

  // publicZone is the location where all the DNS records that are publicly accessible to
  // the internet exist.
  //
  // If this field is nil, no public records should be created.
  //
  // Once set, this field cannot be changed.
  //
  // +optional
  optional DNSZone publicZone = 2;

  // privateZone is the location where all the DNS records that are only available internally
  // to the cluster exist.
  //
  // If this field is nil, no private records should be created.
  //
  // Once set, this field cannot be changed.
  //
  // +optional
  optional DNSZone privateZone = 3;
}

message DNSStatus {
}

message DNSZone {
  // id is the identifier that can be used to find the DNS hosted zone.
  //
  // on AWS zone can be fetched using `ID` as id in [1]
  // on Azure zone can be fetched using `ID` as a pre-determined name in [2],
  // on GCP zone can be fetched using `ID` as a pre-determined name in [3].
  //
  // [1]: https://docs.aws.amazon.com/cli/latest/reference/route53/get-hosted-zone.html#options
  // [2]: https://docs.microsoft.com/en-us/cli/azure/network/dns/zone?view=azure-cli-latest#az-network-dns-zone-show
  // [3]: https://cloud.google.com/dns/docs/reference/v1/managedZones/get
  // +optional
  optional string id = 1;

  // tags can be used to query the DNS hosted zone.
  //
  // on AWS, resourcegroupstaggingapi [1] can be used to fetch a zone using `Tags` as tag-filters,
  //
  // [1]: https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/get-resources.html#options
  // +optional
  map<string, string> tags = 2;
}

message EquinixMetalPlatformSpec {
}

message EquinixMetalPlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 2;
}

message GCPPlatformSpec {
}

message GCPPlatformStatus {
  // resourceGroupName is the Project ID for new GCP resources created for the cluster.
  optional string projectID = 1;

  // region holds the region for new GCP resources created for the cluster.
  optional string region = 2;
}

message IBMCloudPlatformSpec {
}

message IBMCloudPlatformStatus {
  // Location is where the cluster has been deployed
  optional string location = 1;

  // ResourceGroupName is the Resource Group for new IBMCloud resources created for the cluster.
  optional string resourceGroupName = 2;

  // ProviderType indicates the type of cluster that was created
  optional string providerType = 3;

  // CISInstanceCRN is the CRN of the Cloud Internet Services instance managing
  // the DNS zone for the cluster's base domain
  optional string cisInstanceCRN = 4;
}

message Infrastructure {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // spec holds user settable values for configuration
  // +kubebuilder:validation:Required
  // +required
  optional InfrastructureSpec spec = 2;

  // status holds observed values from the cluster. They may not be overridden.
  // +optional
  optional InfrastructureStatus status = 3;
}

message InfrastructureSpec {
  // cloudConfig is a reference to a ConfigMap containing the cloud provider configuration file.
  // This configuration file is used to configure the Kubernetes cloud provider integration
  // when using the built-in cloud provider integration or the external cloud controller manager.
  // The namespace for this config map is openshift-config.
  //
  // cloudConfig should only be consumed by the kube_cloud_config controller.
  // The controller is responsible for using the user configuration in the spec
  // for various platforms and combining that with the user provided ConfigMap in this field
  // to create a stitched kube cloud config.
  // The controller generates a ConfigMap `kube-cloud-config` in `openshift-config-managed` namespace
  // with the kube cloud config is stored in `cloud.conf` key.
  // All the clients are expected to use the generated ConfigMap only.
  //
  // +optional
  optional ConfigMapFileReference cloudConfig = 1;

  // platformSpec holds desired information specific to the underlying
  // infrastructure provider.
  optional PlatformSpec platformSpec = 2;
}

message InfrastructureStatus {
  // infrastructureName uniquely identifies a cluster with a human friendly name.
  // Once set it should not be changed. Must be of max length 27 and must have only
  // alphanumeric or hyphen characters.
  optional string infrastructureName = 1;

  // platform is the underlying infrastructure provider for the cluster.
  //
  // Deprecated: Use platformStatus.type instead.
  optional string platform = 2;

  // platformStatus holds status information specific to the underlying
  // infrastructure provider.
  // +optional
  optional PlatformStatus platformStatus = 3;

  // etcdDiscoveryDomain is the domain used to fetch the SRV records for discovering
  // etcd servers and clients.
  // For more info: https://github.com/etcd-io/etcd/blob/329be66e8b3f9e2e6af83c123ff89297e49ebd15/Documentation/op-guide/clustering.md#dns-discovery
  // deprecated: as of 4.7, this field is no longer set or honored.  It will be removed in a future release.
  optional string etcdDiscoveryDomain = 4;

  // apiServerURL is a valid URI with scheme 'https', address and
  // optionally a port (defaulting to 443).  apiServerURL can be used by components like the web console
  // to tell users where to find the Kubernetes API.
  optional string apiServerURL = 5;

  // apiServerInternalURL is a valid URI with scheme 'https',
  // address and optionally a port (defaulting to 443).  apiServerInternalURL can be used by components
  // like kubelets, to contact the Kubernetes API server using the
  // infrastructure provider rather than Kubernetes networking.
  optional string apiServerInternalURI = 6;

  // controlPlaneTopology expresses the expectations for operands that normally run on control nodes.
  // The default is 'HighlyAvailable', which represents the behavior operators have in a "normal" cluster.
  // The 'SingleReplica' mode will be used in single-node deployments
  // and the operators should not configure the operand for highly-available operation
  // The 'External' mode indicates that the control plane is hosted externally to the cluster and that
  // its components are not visible within the cluster.
  // +kubebuilder:default=HighlyAvailable
  // +kubebuilder:validation:Enum=HighlyAvailable;SingleReplica;External
  optional string controlPlaneTopology = 7;

  // infrastructureTopology expresses the expectations for infrastructure services that do not run on control
  // plane nodes, usually indicated by a node selector for a `role` value
  // other than `master`.
  // The default is 'HighlyAvailable', which represents the behavior operators have in a "normal" cluster.
  // The 'SingleReplica' mode will be used in single-node deployments
  // and the operators should not configure the operand for highly-available operation
  // NOTE: External topology mode is not applicable for this field.
  // +kubebuilder:default=HighlyAvailable
  // +kubebuilder:validation:Enum=HighlyAvailable;SingleReplica
  optional string infrastructureTopology = 8;
}

message IntermediateTLSProfile {
}

message KubevirtPlatformSpec {
}

message KubevirtPlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 2;
}

message ModernTLSProfile {
}

message OldTLSProfile {
}

message OpenStackPlatformSpec {
}

message OpenStackPlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // cloudName is the name of the desired OpenStack cloud in the
  // client configuration file (`clouds.yaml`).
  optional string cloudName = 2;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 3;

  // nodeDNSIP is the IP address for the internal DNS used by the
  // nodes. Unlike the one managed by the DNS operator, `NodeDNSIP`
  // provides name resolution for the nodes themselves. There is no DNS-as-a-service for
  // OpenStack deployments. In order to minimize necessary changes to the
  // datacenter DNS, a DNS service is hosted as a static pod to serve those hostnames
  // to the nodes in the cluster.
  optional string nodeDNSIP = 4;
}

message OvirtPlatformSpec {
}

message OvirtPlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 2;

  // deprecated: as of 4.6, this field is no longer set or honored.  It will be removed in a future release.
  optional string nodeDNSIP = 3;
}

message PlatformSpec {
  // type is the underlying infrastructure provider for the cluster. This
  // value controls whether infrastructure automation such as service load
  // balancers, dynamic volume provisioning, machine creation and deletion, and
  // other integrations are enabled. If None, no infrastructure automation is
  // enabled. Allowed values are "AWS", "Azure", "BareMetal", "GCP", "Libvirt",
  // "OpenStack", "VSphere", "oVirt", "KubeVirt", "EquinixMetal", "PowerVS",
  // "AlibabaCloud" and "None". Individual components may not support all platforms,
  // and must handle unrecognized platforms as None if they do not support that platform.
  //
  // +unionDiscriminator
  optional string type = 1;

  // AWS contains settings specific to the Amazon Web Services infrastructure provider.
  // +optional
  optional AWSPlatformSpec aws = 2;

  // Azure contains settings specific to the Azure infrastructure provider.
  // +optional
  optional AzurePlatformSpec azure = 3;

  // GCP contains settings specific to the Google Cloud Platform infrastructure provider.
  // +optional
  optional GCPPlatformSpec gcp = 4;

  // BareMetal contains settings specific to the BareMetal platform.
  // +optional
  optional BareMetalPlatformSpec baremetal = 5;

  // OpenStack contains settings specific to the OpenStack infrastructure provider.
  // +optional
  optional OpenStackPlatformSpec openstack = 6;

  // Ovirt contains settings specific to the oVirt infrastructure provider.
  // +optional
  optional OvirtPlatformSpec ovirt = 7;

  // VSphere contains settings specific to the VSphere infrastructure provider.
  // +optional
  optional VSpherePlatformSpec vsphere = 8;

  // IBMCloud contains settings specific to the IBMCloud infrastructure provider.
  // +optional
  optional IBMCloudPlatformSpec ibmcloud = 9;

  // Kubevirt contains settings specific to the kubevirt infrastructure provider.
  // +optional
  optional KubevirtPlatformSpec kubevirt = 10;

  // EquinixMetal contains settings specific to the Equinix Metal infrastructure provider.
  // +optional
  optional EquinixMetalPlatformSpec equinixMetal = 11;

  // PowerVS contains settings specific to the IBM Power Systems Virtual Servers infrastructure provider.
  // +optional
  optional PowerVSPlatformSpec powervs = 12;

  // AlibabaCloud contains settings specific to the Alibaba Cloud infrastructure provider.
  // +optional
  optional AlibabaCloudPlatformSpec alibabaCloud = 13;
}

message PlatformStatus {
  // type is the underlying infrastructure provider for the cluster. This
  // value controls whether infrastructure automation such as service load
  // balancers, dynamic volume provisioning, machine creation and deletion, and
  // other integrations are enabled. If None, no infrastructure automation is
  // enabled. Allowed values are "AWS", "Azure", "BareMetal", "GCP", "Libvirt",
  // "OpenStack", "VSphere", "oVirt", "EquinixMetal", "PowerVS", "AlibabaCloud" and "None".
  // Individual components may not support all platforms, and must handle
  // unrecognized platforms as None if they do not support that platform.
  //
  // This value will be synced with to the `status.platform` and `status.platformStatus.type`.
  // Currently this value cannot be changed once set.
  optional string type = 1;

  // AWS contains settings specific to the Amazon Web Services infrastructure provider.
  // +optional
  optional AWSPlatformStatus aws = 2;

  // Azure contains settings specific to the Azure infrastructure provider.
  // +optional
  optional AzurePlatformStatus azure = 3;

  // GCP contains settings specific to the Google Cloud Platform infrastructure provider.
  // +optional
  optional GCPPlatformStatus gcp = 4;

  // BareMetal contains settings specific to the BareMetal platform.
  // +optional
  optional BareMetalPlatformStatus baremetal = 5;

  // OpenStack contains settings specific to the OpenStack infrastructure provider.
  // +optional
  optional OpenStackPlatformStatus openstack = 6;

  // Ovirt contains settings specific to the oVirt infrastructure provider.
  // +optional
  optional OvirtPlatformStatus ovirt = 7;

  // VSphere contains settings specific to the VSphere infrastructure provider.
  // +optional
  optional VSpherePlatformStatus vsphere = 8;

  // IBMCloud contains settings specific to the IBMCloud infrastructure provider.
  // +optional
  optional IBMCloudPlatformStatus ibmcloud = 9;

  // Kubevirt contains settings specific to the kubevirt infrastructure provider.
  // +optional
  optional KubevirtPlatformStatus kubevirt = 10;

  // EquinixMetal contains settings specific to the Equinix Metal infrastructure provider.
  // +optional
  optional EquinixMetalPlatformStatus equinixMetal = 11;

  // PowerVS contains settings specific to the Power Systems Virtual Servers infrastructure provider.
  // +optional
  optional PowerVSPlatformStatus powervs = 12;

  // AlibabaCloud contains settings specific to the Alibaba Cloud infrastructure provider.
  // +optional
  optional AlibabaCloudPlatformStatus alibabaCloud = 13;
}

message PowerVSPlatformSpec {
}

message PowerVSPlatformStatus {
  // region holds the default Power VS region for new Power VS resources created by the cluster.
  optional string region = 1;

  // zone holds the default zone for the new Power VS resources created by the cluster.
  // Note: Currently only single-zone OCP clusters are supported
  optional string zone = 2;

  // serviceEndpoints is a list of custom endpoints which will override the default
  // service endpoints of a Power VS service.
  // +optional
  repeated PowerVSServiceEndpoint serviceEndpoints = 3;

  // CISInstanceCRN is the CRN of the Cloud Internet Services instance managing
  // the DNS zone for the cluster's base domain
  optional string cisInstanceCRN = 4;
}

message PowerVSServiceEndpoint {
  // name is the name of the Power VS service.
  //
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:Pattern=`^[a-z0-9-]+$`
  optional string name = 1;

  // url is fully qualified URI with scheme https, that overrides the default generated
  // endpoint for a client.
  // This must be provided and cannot be empty.
  //
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:Type=string
  // +kubebuilder:validation:Format=uri
  // +kubebuilder:validation:Pattern=`^https://`
  optional string url = 2;
}

message ProxyStatus {
  // httpProxy is the URL of the proxy for HTTP requests.
  // +optional
  optional string httpProxy = 1;

  // httpsProxy is the URL of the proxy for HTTPS requests.
  // +optional
  optional string httpsProxy = 2;

  // noProxy is a comma-separated list of hostnames and/or CIDRs for which the proxy should not be used.
  // +optional
  optional string noProxy = 3;
}

message TLSProfileSpec {
  // ciphers is used to specify the cipher algorithms that are negotiated
  // during the TLS handshake.  Operators may remove entries their operands
  // do not support.  For example, to use DES-CBC3-SHA  (yaml):
  //
  //   ciphers:
  //     - DES-CBC3-SHA
  repeated string ciphers = 1;

  // minTLSVersion is used to specify the minimal version of the TLS protocol
  // that is negotiated during the TLS handshake. For example, to use TLS
  // versions 1.1, 1.2 and 1.3 (yaml):
  //
  //   minTLSVersion: TLSv1.1
  //
  // NOTE: currently the highest minTLSVersion allowed is VersionTLS12
  optional string minTLSVersion = 2;
}

message TLSSecurityProfile {
  // type is one of Old, Intermediate, Modern or Custom. Custom provides
  // the ability to specify individual TLS security profile parameters.
  // Old, Intermediate and Modern are TLS security profiles based on:
  //
  // https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations
  //
  // The profiles are intent based, so they may change over time as new ciphers are developed and existing ciphers
  // are found to be insecure.  Depending on precisely which ciphers are available to a process, the list may be
  // reduced.
  //
  // Note that the Modern profile is currently not supported because it is not
  // yet well adopted by common software libraries.
  //
  // +unionDiscriminator
  // +optional
  optional string type = 1;

  // old is a TLS security profile based on:
  //
  // https://wiki.mozilla.org/Security/Server_Side_TLS#Old_backward_compatibility
  //
  // and looks like this (yaml):
  //
  //   ciphers:
  //     - TLS_AES_128_GCM_SHA256
  //     - TLS_AES_256_GCM_SHA384
  //     - TLS_CHACHA20_POLY1305_SHA256
  //     - ECDHE-ECDSA-AES128-GCM-SHA256
  //     - ECDHE-RSA-AES128-GCM-SHA256
  //     - ECDHE-ECDSA-AES256-GCM-SHA384
  //     - ECDHE-RSA-AES256-GCM-SHA384
  //     - ECDHE-ECDSA-CHACHA20-POLY1305
  //     - ECDHE-RSA-CHACHA20-POLY1305
  //     - DHE-RSA-AES128-GCM-SHA256
  //     - DHE-RSA-AES256-GCM-SHA384
  //     - DHE-RSA-CHACHA20-POLY1305
  //     - ECDHE-ECDSA-AES128-SHA256
  //     - ECDHE-RSA-AES128-SHA256
  //     - ECDHE-ECDSA-AES128-SHA
  //     - ECDHE-RSA-AES128-SHA
  //     - ECDHE-ECDSA-AES256-SHA384
  //     - ECDHE-RSA-AES256-SHA384
  //     - ECDHE-ECDSA-AES256-SHA
  //     - ECDHE-RSA-AES256-SHA
  //     - DHE-RSA-AES128-SHA256
  //     - DHE-RSA-AES256-SHA256
  //     - AES128-GCM-SHA256
  //     - AES256-GCM-SHA384
  //     - AES128-SHA256
  //     - AES256-SHA256
  //     - AES128-SHA
  //     - AES256-SHA
  //     - DES-CBC3-SHA
  //   minTLSVersion: TLSv1.0
  //
  // +optional
  // +nullable
  optional OldTLSProfile old = 2;

  // intermediate is a TLS security profile based on:
  //
  // https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29
  //
  // and looks like this (yaml):
  //
  //   ciphers:
  //     - TLS_AES_128_GCM_SHA256
  //     - TLS_AES_256_GCM_SHA384
  //     - TLS_CHACHA20_POLY1305_SHA256
  //     - ECDHE-ECDSA-AES128-GCM-SHA256
  //     - ECDHE-RSA-AES128-GCM-SHA256
  //     - ECDHE-ECDSA-AES256-GCM-SHA384
  //     - ECDHE-RSA-AES256-GCM-SHA384
  //     - ECDHE-ECDSA-CHACHA20-POLY1305
  //     - ECDHE-RSA-CHACHA20-POLY1305
  //     - DHE-RSA-AES128-GCM-SHA256
  //     - DHE-RSA-AES256-GCM-SHA384
  //   minTLSVersion: TLSv1.2
  //
  // +optional
  // +nullable
  optional IntermediateTLSProfile intermediate = 3;

  // modern is a TLS security profile based on:
  //
  // https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility
  //
  // and looks like this (yaml):
  //
  //   ciphers:
  //     - TLS_AES_128_GCM_SHA256
  //     - TLS_AES_256_GCM_SHA384
  //     - TLS_CHACHA20_POLY1305_SHA256
  //   minTLSVersion: TLSv1.3
  //
  // NOTE: Currently unsupported.
  //
  // +optional
  // +nullable
  optional ModernTLSProfile modern = 4;

  // custom is a user-defined TLS security profile. Be extremely careful using a custom
  // profile as invalid configurations can be catastrophic. An example custom profile
  // looks like this:
  //
  //   ciphers:
  //     - ECDHE-ECDSA-CHACHA20-POLY1305
  //     - ECDHE-RSA-CHACHA20-POLY1305
  //     - ECDHE-RSA-AES128-GCM-SHA256
  //     - ECDHE-ECDSA-AES128-GCM-SHA256
  //   minTLSVersion: TLSv1.1
  //
  // +optional
  // +nullable
  optional CustomTLSProfile custom = 5;
}

message VSpherePlatformSpec {
}

message VSpherePlatformStatus {
  // apiServerInternalIP is an IP address to contact the Kubernetes API server that can be used
  // by components inside the cluster, like kubelets using the infrastructure rather
  // than Kubernetes networking. It is the IP that the Infrastructure.status.apiServerInternalURI
  // points to. It is the IP for a self-hosted load balancer in front of the API servers.
  optional string apiServerInternalIP = 1;

  // ingressIP is an external IP which routes to the default ingress controller.
  // The IP is a suitable target of a wildcard DNS record used to resolve default route host names.
  optional string ingressIP = 2;

  // nodeDNSIP is the IP address for the internal DNS used by the
  // nodes. Unlike the one managed by the DNS operator, `NodeDNSIP`
  // provides name resolution for the nodes themselves. There is no DNS-as-a-service for
  // vSphere deployments. In order to minimize necessary changes to the
  // datacenter DNS, a DNS service is hosted as a static pod to serve those hostnames
  // to the nodes in the cluster.
  optional string nodeDNSIP = 3;
}

// ContainerRuntimeConfig describes a customized Container Runtime configuration.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message ContainerRuntimeConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +required
  optional ContainerRuntimeConfigSpec spec = 2;

  // +optional
  optional ContainerRuntimeConfigStatus status = 3;
}

// ContainerRuntimeConfigCondition defines the state of the ContainerRuntimeConfig
message ContainerRuntimeConfigCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  // +nullable
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are PascalCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// ContainerRuntimeConfigList is a list of ContainerRuntimeConfig resources
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message ContainerRuntimeConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ContainerRuntimeConfig items = 2;
}

// ContainerRuntimeConfigSpec defines the desired state of ContainerRuntimeConfig
message ContainerRuntimeConfigSpec {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigPoolSelector = 1;

  optional ContainerRuntimeConfiguration containerRuntimeConfig = 2;
}

// ContainerRuntimeConfigStatus defines the observed state of a ContainerRuntimeConfig
message ContainerRuntimeConfigStatus {
  // observedGeneration represents the generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 1;

  // conditions represents the latest available observations of current state.
  // +optional
  repeated ContainerRuntimeConfigCondition conditions = 2;
}

// ContainerRuntimeConfiguration defines the tuneables of the container runtime
message ContainerRuntimeConfiguration {
  // pidsLimit specifies the maximum number of processes allowed in a container
  optional int64 pidsLimit = 1;

  // logLevel specifies the verbosity of the logs based on the level it is set to.
  // Options are fatal, panic, error, warn, info, and debug.
  optional string logLevel = 2;

  // logSizeMax specifies the Maximum size allowed for the container log file.
  // Negative numbers indicate that no size limit is imposed.
  // If it is positive, it must be >= 8192 to match/exceed conmon's read buffer.
  optional k8s.io.apimachinery.pkg.api.resource.Quantity logSizeMax = 3;

  // overlaySize specifies the maximum size of a container image.
  // This flag can be used to set quota on the size of container images. (default: 10GB)
  optional k8s.io.apimachinery.pkg.api.resource.Quantity overlaySize = 4;
}

// ControllerConfig describes configuration for MachineConfigController.
// This is currently only used to drive the MachineConfig objects generated by the TemplateController.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message ControllerConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +required
  optional ControllerConfigSpec spec = 2;

  // +optional
  optional ControllerConfigStatus status = 3;
}

// ControllerConfigList is a list of ControllerConfig resources
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message ControllerConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ControllerConfig items = 2;
}

// ControllerConfigSpec is the spec for ControllerConfig resource.
message ControllerConfigSpec {
  // clusterDNSIP is the cluster DNS IP address
  optional string clusterDNSIP = 1;

  // cloudProviderConfig is the configuration for the given cloud provider
  optional string cloudProviderConfig = 2;

  // platform is deprecated, use Infra.Status.PlatformStatus.Type instead
  optional string platform = 3;

  // etcdDiscoveryDomain is deprecated, use Infra.Status.EtcdDiscoveryDomain instead
  optional string etcdDiscoveryDomain = 4;

  // kubeAPIServerServingCAData managed Kubelet to API Server Cert... Rotated automatically
  optional bytes kubeAPIServerServingCAData = 5;

  // rootCAData specifies the root CA data
  optional bytes rootCAData = 6;

  // cloudProvider specifies the cloud provider CA data
  // +nullable
  optional bytes cloudProviderCAData = 7;

  // additionalTrustBundle is a certificate bundle that will be added to the nodes
  // trusted certificate store.
  // +nullable
  optional bytes additionalTrustBundle = 8;

  // pullSecret is the default pull secret that needs to be installed
  // on all machines.
  optional k8s.io.api.core.v1.ObjectReference pullSecret = 9;

  // images is map of images that are used by the controller to render templates under ./templates/
  map<string, string> images = 10;

  // osImageURL is the location of the container image that contains the OS update payload.
  // Its value is taken from the data.osImageURL field on the machine-config-osimageurl ConfigMap.
  optional string osImageURL = 11;

  // releaseImage is the image used when installing the cluster
  optional string releaseImage = 12;

  // proxy holds the current proxy configuration for the nodes
  // +nullable
  optional ProxyStatus proxy = 13;

  // infra holds the infrastructure details
  // +nullable
  optional Infrastructure infra = 14;

  // dns holds the cluster dns details
  // +nullable
  optional DNS dns = 15;

  // ipFamilies indicates the IP families in use by the cluster network
  optional string ipFamilies = 16;

  // networkType holds the type of network the cluster is using
  // XXX: this is temporary and will be dropped as soon as possible in favor of a better support
  // to start network related services the proper way.
  // Nobody is also changing this once the cluster is up and running the first time, so, disallow
  // regeneration if this changes.
  optional string networkType = 17;
}

// ControllerConfigStatus is the status for ControllerConfig
message ControllerConfigStatus {
  // observedGeneration represents the generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 1;

  // conditions represents the latest available observations of current state.
  // +optional
  repeated ControllerConfigStatusCondition conditions = 2;
}

// ControllerConfigStatusCondition contains condition information for ControllerConfigStatus
message ControllerConfigStatusCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  // +nullable
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are PascalCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// KubeletConfig describes a customized Kubelet configuration.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message KubeletConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +required
  optional KubeletConfigSpec spec = 2;

  // +optional
  optional KubeletConfigStatus status = 3;
}

// KubeletConfigCondition defines the state of the KubeletConfig
message KubeletConfigCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  // +nullable
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are PascalCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// KubeletConfigList is a list of KubeletConfig resources
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message KubeletConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubeletConfig items = 2;
}

// KubeletConfigSpec defines the desired state of KubeletConfig
message KubeletConfigSpec {
  optional bool autoSizingReserved = 1;

  optional int32 logLevel = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigPoolSelector = 3;

  optional k8s.io.apimachinery.pkg.runtime.RawExtension kubeletConfig = 4;

  // If unset, the default is based on the apiservers.config.openshift.io/cluster resource.
  // Note that only Old and Intermediate profiles are currently supported, and
  // the maximum available MinTLSVersions is VersionTLS12.
  // +optional
  optional TLSSecurityProfile tlsSecurityProfile = 5;
}

// KubeletConfigStatus defines the observed state of a KubeletConfig
message KubeletConfigStatus {
  // observedGeneration represents the generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 1;

  // conditions represents the latest available observations of current state.
  // +optional
  repeated KubeletConfigCondition conditions = 2;
}

// MachineConfig defines the configuration for a machine
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message MachineConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MachineConfigSpec spec = 2;
}

// MachineConfigList is a list of MachineConfig resources
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message MachineConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MachineConfig items = 2;
}

// MachineConfigPool describes a pool of MachineConfigs.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message MachineConfigPool {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +required
  optional MachineConfigPoolSpec spec = 2;

  // +optional
  optional MachineConfigPoolStatus status = 3;
}

// MachineConfigPoolCondition contains condition information for an MachineConfigPool.
message MachineConfigPoolCondition {
  // type of the condition, currently ('Done', 'Updating', 'Failed').
  optional string type = 1;

  // status of the condition, one of ('True', 'False', 'Unknown').
  optional string status = 2;

  // lastTransitionTime is the timestamp corresponding to the last status
  // change of this condition.
  // +nullable
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is a brief machine readable explanation for the condition's last
  // transition.
  optional string reason = 4;

  // message is a human readable description of the details of the last
  // transition, complementing reason.
  optional string message = 5;
}

// MachineConfigPoolList is a list of MachineConfigPool resources
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
message MachineConfigPoolList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MachineConfigPool items = 2;
}

// MachineConfigPoolSpec is the spec for MachineConfigPool resource.
message MachineConfigPoolSpec {
  // machineConfigSelector specifies a label selector for MachineConfigs.
  // Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ on how label and selectors work.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigSelector = 1;

  // nodeSelector specifies a label selector for Machines
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeSelector = 2;

  // paused specifies whether or not changes to this machine config pool should be stopped.
  // This includes generating new desiredMachineConfig and update of machines.
  optional bool paused = 3;

  // maxUnavailable specifies the percentage or constant number of machines that can be updating at any given time.
  // default is 1.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 4;

  // The targeted MachineConfig object for the machine config pool.
  optional MachineConfigPoolStatusConfiguration configuration = 5;
}

// MachineConfigPoolStatus is the status for MachineConfigPool resource.
message MachineConfigPoolStatus {
  // observedGeneration represents the generation observed by the controller.
  // +optional
  optional int64 observedGeneration = 1;

  // configuration represents the current MachineConfig object for the machine config pool.
  optional MachineConfigPoolStatusConfiguration configuration = 2;

  // machineCount represents the total number of machines in the machine config pool.
  optional int32 machineCount = 3;

  // updatedMachineCount represents the total number of machines targeted by the pool that have the CurrentMachineConfig as their config.
  optional int32 updatedMachineCount = 4;

  // readyMachineCount represents the total number of ready machines targeted by the pool.
  optional int32 readyMachineCount = 5;

  // unavailableMachineCount represents the total number of unavailable (non-ready) machines targeted by the pool.
  // A node is marked unavailable if it is in updating state or NodeReady condition is false.
  optional int32 unavailableMachineCount = 6;

  // degradedMachineCount represents the total number of machines marked degraded (or unreconcilable).
  // A node is marked degraded if applying a configuration failed..
  optional int32 degradedMachineCount = 7;

  // conditions represents the latest available observations of current state.
  // +optional
  repeated MachineConfigPoolCondition conditions = 8;
}

// MachineConfigPoolStatusConfiguration stores the current configuration for the pool, and
// optionally also stores the list of MachineConfig objects used to generate the configuration.
message MachineConfigPoolStatusConfiguration {
  optional k8s.io.api.core.v1.ObjectReference objectReference = 1;

  // source is the list of MachineConfig objects that were used to generate the single MachineConfig object specified in `content`.
  // +optional
  repeated k8s.io.api.core.v1.ObjectReference source = 2;
}

// MachineConfigSpec is the spec for MachineConfig
message MachineConfigSpec {
  // OSImageURL specifies the remote location that will be used to
  // fetch the OS.
  optional string osImageURL = 1;

  // Config is a Ignition Config object.
  optional k8s.io.apimachinery.pkg.runtime.RawExtension config = 2;

  // +nullable
  repeated string kernelArguments = 3;

  repeated string extensions = 4;

  optional bool fips = 5;

  optional string kernelType = 6;
}

